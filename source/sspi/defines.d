module sspi.defines;

version(Windows):
import core.sys.windows.ntsecpkg;
import core.sys.windows.sspi;
import core.sys.windows.security;


enum SecPkgFlag
{
	integrity = SECPKG_FLAG_INTEGRITY,
	privacy = SECPKG_FLAG_PRIVACY,
	tokenOnly = SECPKG_FLAG_TOKEN_ONLY,
	datagram = SECPKG_FLAG_DATAGRAM,
	connection = SECPKG_FLAG_CONNECTION,
	multiRequired = SECPKG_FLAG_MULTI_REQUIRED,
	clientOnly = SECPKG_FLAG_CLIENT_ONLY,
	extendedError = SECPKG_FLAG_EXTENDED_ERROR,
	impersonation = SECPKG_FLAG_IMPERSONATION,
	acceptWin32Name = SECPKG_FLAG_ACCEPT_WIN32_NAME,
	stream = SECPKG_FLAG_STREAM,
}


enum SecPackageAttribute
{
	authority = SECPKG_ATTR_AUTHORITY,
	connectionInfo = SECPKG_ATTR_CONNECTION_INFO,
	issuerList = SECPKG_ATTR_ISSUER_LIST,
	issuerListEx = SECPKG_ATTR_ISSUER_LIST_EX,
	keyInfo = SECPKG_ATTR_KEY_INFO,
	lifespan = SECPKG_ATTR_LIFESPAN,
	localCertContext = SECPKG_ATTR_LOCAL_CERT_CONTEXT,
	localCred = SECPKG_ATTR_LOCAL_CRED,
	names = SECPKG_ATTR_NAMES,
	protoInfo = SECPKG_ATTR_PROTO_INFO,
	remoteCertContext = SECPKG_ATTR_REMOTE_CERT_CONTEXT,
	remoteCred = SECPKG_ATTR_REMOTE_CRED,
	sizes = SECPKG_ATTR_SIZES,
	streamSizes = SECPKG_ATTR_STREAM_SIZES,
}

struct SecPkgContext_NegotiationInfoW
{
	SecPkgInfoW*  packageInfo;
	ulong negotiationState;
}


enum SecurityStatus
{
    okay = 0,
	// bufferTooSmall = SECURITY_STATUS.SEC_E_BUFFER_TOO_SMALL,
	// contextExpired = SECURITY_STATUS.SEC_E_CONTEXT_EXPIRED,
    // SEC_E_CERT_EXPIRED = (-2146893016),
	// cryptoSystemInvalid = SECURITY_STATUS.SEC_E_CRYPTO_SYSTEM_INVALID,
    insufficientMemory =(-2146893056),
    invalidHandle = (-2146893055),
    invalidToken = (-2146893048),
	qopNotSupported = (-2146893046),
	//outOfSequence = SECURITY_STATUS.SEC_E_OUT_OF_SEQUENCE,
	//messageAltered = SECURITY_STATUS.SEC_E_MESSAGE_ALTERED,
    completeAndContinue = 590612,
    completeNeeded = 590611,
}
/+
enum :SECURITY_STATUS{
    SEC_E_OK = 0,
    SEC_E_CERT_EXPIRED = (-2146893016),
    SEC_E_INCOMPLETE_MESSAGE = (-2146893032),
    SEC_E_INSUFFICIENT_MEMORY = (-2146893056),
    SEC_E_INTERNAL_ERROR = (-2146893052),
    SEC_E_INVALID_HANDLE = (-2146893055),
    SEC_E_INVALID_TOKEN = (-2146893048),
    SEC_E_LOGON_DENIED = (-2146893044),
    SEC_E_NO_AUTHENTICATING_AUTHORITY = (-2146893039),
    SEC_E_NO_CREDENTIALS = (-2146893042),
    SEC_E_TARGET_UNKNOWN = (-2146893053),
    SEC_E_UNSUPPORTED_FUNCTION = (-2146893054),
    SEC_E_UNTRUSTED_ROOT = (-2146893019),
    SEC_E_WRONG_PRINCIPAL = (-2146893022),
    SEC_E_SECPKG_NOT_FOUND = (-2146893051),
    SEC_E_QOP_NOT_SUPPORTED = (-2146893046),
    SEC_E_UNKNOWN_CREDENTIALS = (-2146893043),
    SEC_E_NOT_OWNER = (-2146893050),
}
enum :SECURITY_STATUS {
    SEC_I_RENEGOTIATE = 590625,
    SEC_I_COMPLETE_AND_CONTINUE = 590612,
    SEC_I_COMPLETE_NEEDED = 590611,
    SEC_I_CONTINUE_NEEDED = 590610,
    SEC_I_INCOMPLETE_CREDENTIALS = 590624,
}
+/


enum IscReq
{
	delegate_ = ISC_REQ_DELEGATE,
	mutualAuth = ISC_REQ_MUTUAL_AUTH,
	replayDetect = ISC_REQ_REPLAY_DETECT,
	sequenceDetect = ISC_REQ_SEQUENCE_DETECT,
	confidentiality = ISC_REQ_CONFIDENTIALITY,
	useSessionKey = ISC_REQ_USE_SESSION_KEY,
	promptForCreds = ISC_REQ_PROMPT_FOR_CREDS,
	useSuppliedCreds = ISC_REQ_USE_SUPPLIED_CREDS,
	allocateMemory = ISC_REQ_ALLOCATE_MEMORY,
	useDceStyle = ISC_REQ_USE_DCE_STYLE,
	datagram = ISC_REQ_DATAGRAM,
	connection = ISC_REQ_CONNECTION,
	extendedError = ISC_REQ_EXTENDED_ERROR,
	stream = ISC_REQ_STREAM,
	integrity = ISC_REQ_INTEGRITY,
	manualCredValidation = ISC_REQ_MANUAL_CRED_VALIDATION,
	http = ISC_REQ_HTTP,
}

